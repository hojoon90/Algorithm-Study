# 탐욕법 - 조이스틱
#### 프로그래머스 https://programmers.co.kr/learn/courses/30/lessons/42860

### 문제 설명
조이스틱으로 알파벳 이름을 완성하세요. 맨 처음엔 A로만 이루어져 있습니다.\
ex) 완성해야 하는 이름이 세 글자면 AAA, 네 글자면 AAAA

조이스틱을 각 방향으로 움직이면 아래와 같습니다.

▲ - 다음 알파벳\
▼ - 이전 알파벳 (A에서 아래쪽으로 이동하면 Z로)\
◀ - 커서를 왼쪽으로 이동 (첫 번째 위치에서 왼쪽으로 이동하면 마지막 문자에 커서)\
▶ - 커서를 오른쪽으로 이동 (마지막 위치에서 오른쪽으로 이동하면 첫 번째 문자에 커서)\
예를 들어 아래의 방법으로 "JAZ"를 만들 수 있습니다.

- 첫 번째 위치에서 조이스틱을 위로 9번 조작하여 J를 완성합니다.
- 조이스틱을 왼쪽으로 1번 조작하여 커서를 마지막 문자 위치로 이동시킵니다.
- 마지막 위치에서 조이스틱을 아래로 1번 조작하여 Z를 완성합니다.
따라서 11번 이동시켜 "JAZ"를 만들 수 있고, 이때가 최소 이동입니다.
만들고자 하는 이름 name이 매개변수로 주어질 때, 이름에 대해 조이스틱 조작 횟수의 최솟값을 return 하도록 solution 함수를 만드세요.

### 제한 사항
name은 알파벳 대문자로만 이루어져 있습니다.\
name의 길이는 1 이상 20 이하입니다.\
입출력 예\
name	return\
"JEROEN"	56\
"JAN"	23\

### 입출력 예

|name|return|
|---|---|
|"JEROEN"|56|
|"JAN"|23|

### 문제풀이

**참고: https://school.programmers.co.kr/questions/26014**

```python
def solution(name):
    if set(name) == {'A'}:
        return 0

    answer = float('inf')
    for i in range(len(name) // 2):
        left_moved = name[-i:]+name[:-i]
        right_moved = name[i:]+name[:i]
        for n in [left_moved, right_moved[0]+right_moved[:0:-1]]:
            while n and n[-1] == 'A':
                n = n[:-1]

            row_move = i + len(n)-1
            col_move = 0
            for c in map(ord, n):
                col_move += min(c - 65, 91 - c)

            answer = min(answer, row_move + col_move)

    return answer
```

이번 문제는 도저히 붙잡아도 풀리지 않아서 프로그래머스 질문 게시판에서 정답을 찾았다... 근데 질문 게시판에 올라 오는 글 전부 그리디 문제가 아니라는 이야기가 있더라...
어쩐지 뭔가 접근이 쉽지 않았다고 느꼈다.\
일단 풀이를 보면 answer 값을 무한으로 지정 해놓고 시작 한다. 그 후 name 길이의 절반의 숫자를 for 문으로 돌려 주는데, 이건 아래 왼쪽과 오른쪽 이동을 모두 하기 때문에
절반만 for문이 실행 되도록 해준다. \
안에는 left_moved 와 right_moved 변수에 각각 이동 했을 때 오는 문자가 제일 앞에 온다. 만약 'JEROEN'을 예시로 한다면 첫번째는 둘다 JEROEN이, 
두번째는 각각 left_moved는 'NJEROE', right_moved 는 'EROENJ'가 된다.\
안의 for문에서는 left_moved와 right_moved를 배열에 넣는데, right_moved 는 앞글자를 제외한 나머지 글자를 거꾸로 정렬한다. 만약 첫번째의 경우라면 배열의 내용은
['JEROEN', 'JNEORE'] 가 된다. 처음엔 배열에 넣을 때 right_moved의 정렬을 왜 변경하는지 이해하지 못했었는데, 바로 아래 while문을 보고 이해할 수 있었다.\
while 문에서는 A단어가 있을 경우 바로 다음 글자로 넘어가게 되는데, 좌측 이동의 경우는 뒷 글자가 하나씩 앞으로 오기 때문에 맨 뒤에 A 글자가 있으면 자연스레 체크가 가능하다.
하지만 우측이동의 경우는 단어 사이에 있는 A 체크가 쉽지 않기 때문에 아예 뒤집어서 뒤에서 체크할 수 있도록 코드를 만들어 주었다. 이 상태에서 각각 A 글자가 있을 경우 Pass 할 수 
있게 된다.\
그 후 한칸씩 이동하는 카운트를 세는 row_move 와 글자를 움직이는 카운트를 세는 col_move 가 있는데, col_move의 경우는 글자의 아스키값을 얻어온 후 A에서 이동하는 값과
Z에서 이동하는 값중 가장 짧은 값을 찾아 더해준다. 그리고 나서 answer에 위 두개의 변수가 합쳐진 값을 넣어준다.

### 회고
지금 까지 푼 문제 중에서 제일 난이도 있던 문제가 아닐까 생각 한다. 솔직히 이야기 하면 문제 자체도 더러운 느ㄲ...... 아무튼 그렇다. 다만 이번 문제의 풀이를 보면서 
아직 나는 한참 부족 하다는 것도 같이 느낄수 있었다. 왼쪽 오른쪽 이동에 대한 표현을 저렇게 한다는 것도 놀라 웠을 뿐 아니라 A 단어에 대해 필터링 하는 처리를 단어의 순서를
바꿔서 처리 한다는 것에 꽤 놀라운 느낌을 받을 수 있었다. 거기다 최소 이동 수 구하는 코드... 처음에 코딩할 때만 해도 A에서 위로 올라가 는 카운드와 Z에서 내려 가는 카운트를
세서 비교했었는데 min 함수 안에서 가장 작은것만 구하면 되는 것을 보고... 허탈한 느낌도 없지 않아 있었다. 이래 저래 요즘 상황도 그렇고... 뭔가 많은 생각을 들게 하는 문제였다.